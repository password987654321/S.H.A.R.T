import os, subprocess, sys
from multiprocessing import Process
import angr, claripy
import ropgadget
import json, requests
from colorama import Fore, Back, Style
from pwn import *

# This helps debugging to shutup pwntools
context.log_level = 'ERROR'
logging.disable(logging.CRITICAL)

# Access token for team to make api calls -- CHANGE THIS
access_token = "ctfd_489823be103a92f08ed1e04953ac1891cd84424d401789f475236eaf33db165d"

# URL of ctfd --
ctfd_url = "https://ace.ctfd.io"

# Headers needed for api calls
headers = {
    "Authorization": f"Token {access_token}",
    "Content-Type" : "application/json",
}

UR_MOM_LOL = 8096

# Regex to help find flags in recvall
flag_pattern = r'flag\{[^}]+\}'

# ------------------------------------------------- #
# This is where your auto exploit code should be    #
# placed. This should craft the exploit locally to  #
# get the fake flag, send the exploit to the remote #
# binary, receive the flag, and submit the flag     #
# ------------------------------------------------- #


class SHART:
    def __init__(self, filename:str, chal_id:int) -> None:
        self.file = filename
        self.chal_id = chal_id
        
        self.libc_path = "/opt/libc.so.6"
        self.ld_path = "/opt/ld-2.27.so"
        
        self.bin = context.binary = ELF(filename)
        self.libc = context.binary = ELF(self.libc_path)
        
        self.rop = ROP(self.bin)
        
        self.has_leak = False
        self.has_overflow = False
        
        self.state = None
        self.angrBuffer = None
        self.buffer = None
        self.payload = None
        
        self.angrProj = angr.Project(filename, load_options={"auto_load_libs":False})
        self.angrCfg = self.angrProj.analyses.CFGFast()
        self.angrFunc = self.angrCfg.kb.functions
        self.angrSimgr = None
        
        self.recipe = {
                "filename":filename,
                "ret2win":False,
                "ret2system":False,
                "ret2execve":False,
                "ret2syscall":False,
                "ret2libc":False,
                "ROPWritePrim":False,
                "FormStrStackLeak":False,
                "FormStrLibcLeak":False,
                "FormStrWritePrim":False,
                "FormStrGOTOver":False,
                "ArrayIndexAbuse":False
                }
        
        self.flag = None
        
    def __check_mem_corruption(self, simgr):
        if len(simgr.unconstrained):
            for path in simgr.unconstrained:
                path.add_constraints(path.regs.pc == b"AAAAAAAA")
                if path.satisfiable():
                    temp_buffer = path.solver.eval(self.angrBuffer, cast_to=bytes)
                    try:
                        ind = temp_buffer.index(b"AAAAAAAA")
                        self.buffer = temp_buffer[:ind]
                        simgr.stashes["corrupt"].append(path)
                    except Exception as e:
                        print(f"{self.file}: Angr failed to find index!")
                        # print(temp_buffer)
                simgr.stashes["unconstrained"].remove(path)
                simgr.drop(stash="active")
        
    def __init_angr(self):
        
        print(Fore.RED + Style.BRIGHT + f"Analyzing {self.file}: Initializing Angr." + Style.RESET_ALL)
        
        inp_size = 1000
        
        self.angrBuffer = claripy.BVS("input", 8 * inp_size)
                
        self.state = self.angrProj.factory.entry_state(addr=self.bin.sym["main"], stdin=self.angrBuffer)#, add_options=angr.options.unicorn)
        self.angrSimgr = self.angrProj.factory.simgr(self.state, save_unconstrained=True)
        self.angrSimgr.stashes["corrupt"] = []
        self.angrSimgr.stashes["format"] = []
        
        # def is_leakable(state):
        #     pointer = state.solver.eval(state.regs.rdi)
        #     if pointer >= 0xffffffffff:
        #         self.has_leak = True
        
        def prevent_death(state):
            read_size = state.solver.eval(state.regs.rsi)
            if read_size >= UR_MOM_LOL:
                self.angrSimgr.drop(stash = "active")
                
        self.angrProj.hook_symbol("fgets", prevent_death)
        # self.angrProj.hook_symbol("printf", is_leakable)
        
        print(Fore.GREEN + Style.BRIGHT + f"Analyzing {self.file}: Simulation Active." + Style.RESET_ALL)
        
        self.angrSimgr.explore(step_func=self.__check_mem_corruption)
        
        print(Fore.GREEN + Style.BRIGHT + f"Analyzing {self.file}: Simulation Completed." + Style.RESET_ALL)
        
        for error in self.angrSimgr.errored:
            if str(error.error) == "Symbolic (format) string, game over :(":
                print("Printf Leak Found!")
                self.has_leak = True
        
        if len(self.angrSimgr.stashes["corrupt"]) == 0:
            print(Fore.YELLOW + Style.BRIGHT + f"Analyzing {self.file}: Angr Failed to Find Overflow." + Style.RESET_ALL)
        else:
            self.has_overflow = True
        self.angrSimgr = None
        self.angrProj = None
        
    def __gdb_overflow(self):
        print(Fore.YELLOW + Style.BRIGHT + f"Analyzing {self.file}: GDB Fallback." + Style.RESET_ALL)
        
        # Thanks Louis! https://github.com/condor0010
        
        context.log_level = 'critical'
        content_to_write = "file "+self.file+"\nrun <<< " + cyclic(2048).decode("utf-8") + "\nprint $rbp"
        file_name = str(random.randint(1000000000,9999999999))+".gdb"
        with open(file_name, 'w') as file: file.write(content_to_write)
        out = subprocess.run(["gdb", "-x", file_name, "-batch"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True).stdout
        try:
            size = cyclic_find(p64(int(out.strip().split(' ')[-1],16))) + 8
        except ValueError as e:
            size = 0
        os.remove(file_name)
        if size <= 0:
            print(f"{self.file}: Overflow Not Successfull! {self.has_leak}")
        else:
            self.has_overflow = True
            self.buffer = b"A" * size
                        
    
    def __find_imp_strings(self):
        test = 0
        
        
    def send_flag(self):
        challenge_url = f"{ctfd_url}/api/v1/challenges/attempt"
        data = json.dumps({"challenge_id" : self.chal_id, "submission" : self.flag})
        response = requests.post(challenge_url, headers=headers, data=data)

    def send_exploit(self):
        url = f"ace-service-{self.file}.chals.io"
        p = remote(url, 443, ssl=True, sni=url)
        p.recvuntil(">>>\n")     # Should all be the same (this will be clarified)
        p.sendline(self.payload)
        flag = re.findall(flag_pattern, p.recvall(timeout=0.5).decode())[0]
        if flag:
            self.send_flag()
        else:
            # This comment is for Curtice <3
            raise Exception("We missed the toilet!")

    def exploit(self):
        p = process(f"./{self.file}")
        
        
        # Given the recipe, the tool will try to exploit the binary in the fashion required by the type of exploit(s) detected
        
        print(Fore.CYAN + Style.BRIGHT + f"Exploiting {self.file}: Exploits Initiated" + Style.RESET_ALL)
        
        # You may make functions to make your exploits easier to read/do. Make sure that the parameters are static like in the "runner" function.
        # self.buffer contains the buffer up before overwriting the return address.
        # self.payload must contain the pwning payload. 
        
        if self.recipe["ret2win"]:
            self.flag = re.findall(flag_pattern, p.recvall(timeout=0.5).decode("ascii"))[0]
            p.close()
        if self.recipe["ret2system"] and self.flag == None:
            self.flag = re.findall(flag_pattern, p.recvall(timeout=0.5).decode("ascii"))[0]
            p.close()
        if self.recipe["ret2execve"] and self.flag == None:
            self.flag = re.findall(flag_pattern, p.recvall(timeout=0.5).decode("ascii"))[0]
            p.close()
        if self.recipe["ret2syscall"] and self.flag == None:
            self.flag = re.findall(flag_pattern, p.recvall(timeout=0.5).decode("ascii"))[0]
            p.close()
        if self.recipe["ret2libc"] and self.flag == None:
            self.flag = re.findall(flag_pattern, p.recvall(timeout=0.5).decode("ascii"))[0]
        if self.recipe["ROPWritePrim"] and self.flag == None:
            self.flag = re.findall(flag_pattern, p.recvall(timeout=0.5).decode("ascii"))[0]
            p.close()
        if self.recipe["FormStrStackLeak"] and self.flag == None:
            self.flag = re.findall(flag_pattern, p.recvall(timeout=0.5).decode("ascii"))[0]
            p.close()
        if self.recipe["FormStrLibcLeak"] and self.flag == None:
            self.flag = re.findall(flag_pattern, p.recvall(timeout=0.5).decode("ascii"))[0]
            p.close()
        if self.recipe["FormStrWritePrim"] and self.flag == None:
            self.flag = re.findall(flag_pattern, p.recvall(timeout=0.5).decode("ascii"))[0]
            p.close()
        if self.recipe["FormStrGOTOver"] and self.flag == None:
            self.flag = re.findall(flag_pattern, p.recvall(timeout=0.5).decode("ascii"))[0]
            p.close()
        if self.recipe["ArrayIndexAbuse"] and self.flag == None:
            self.flag = re.findall(flag_pattern, p.recvall(timeout=0.5).decode("ascii"))[0]
            p.close()

        if self.flag:
            print(f"Found flag {self.file}: {self.flag[0]}")
            self.send_exploit()
        else:
            print(Fore.MAGENTA + Style.BRIGHT + f"Exploiting {self.file}: No Exploit Landed. There Goes Our Streak." + Style.RESET_ALL)
        
    def analyze(self) -> None:
        
        # Overflow and printf leak detection.
        self.__init_angr()
        if self.buffer == None:
            # Backup overflow detection.
            self.__gdb_overflow()
            
        print(Fore.MAGENTA + f"{self.buffer}" + Style.RESET_ALL)
                    
        # Analyze possible attacks and mark the recipe.
        
        if self.has_leak:
            if self.has_overflow: # Detecting FS Libc Leak
                test = 0
            else:
                test = 0 # FS Stuff
        elif self.has_overflow:
            test = 0 # ROP Stuff
        else: 
            test = 0 # ArrayIndexAbuse

            
def runner(filename:str, chal_id:int):
    run = SHART(filename, chal_id)
    run.analyze()
    #run.exploit()
    

if __name__ == "__main__":
        

    # ----- Download Binary Repo ----- #
    while(1):
        try:
            # subprocess.run("git clone https://github.com/tj-oconnor/ace-binaries.git", shell=True)
            os.chdir("ace-binaries/test-binaries") # CHANGE THIS EVENTUALLY
            break
        except Exception as e:
            print("Failed to clone git repo!")
    # -------------------------------- #


    # ----- Get the first chal id ---- #
    challenge_url = f"{ctfd_url}/api/v1/challenges"
    response = requests.get(challenge_url, headers=headers)
    json_data = json.loads(response.text).get("data", {})
    challenge_list = {i["name"]: int(i["id"]) for i in json_data}
    # -------------------------------- #

    # ----- Main Execution Loop! ----- #  
    jobs = []
    filenames = os.listdir()
    for file in filenames:
        if file != "flag.txt" or file != "exploit.py":
            jobs.append(Process(target=runner, args=(file, challenge_list[file])))
    for job in jobs:
        sleep(1)
        job.start()
    sleep(30)
    for job in jobs:
        job.join()        
